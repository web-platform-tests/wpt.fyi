<!--
Copyright 2018 The WPT Dashboard Project. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
-->

<link rel="import" href="../bower_components/polymer/polymer-element.html">
<link rel="import" href="../bower_components/google-chart/google-chart.html">

<dom-module id="test-results-chart">
  <style>
    google-chart.false {
      display: none;
    }
  </style>
  <template>
    <google-chart class$="[[isFeasible]]" type="line" cols="[[cols]]" rows="[[rows]]"></google-chart>
  </template>
  <script>
    class TestResultsChart extends window.Polymer.Element {
      static get is() {
        return 'test-results-chart';
      }

      static get properties() {
        return {
          labels: {
            type: Array,
          },
          latest: {
            type: Date,
          },
          tests: {
            type: Array,
          },
          chunkSize: {
            type: Number,
            value: 5,
          },
          maxReqs: {
            type: Number,
            value: 200,
          },
          browserNames: {
            type: Array,
            value: [
              'chrome',
              'edge',
              'firefox',
              'safari',
            ],
          },
          cols: {
            type: Array,
            computed: '_computeCols(browserNames)',
          },
          rows: {
            type: Array,
            value: [],
          },
          values: {
            type: Array,
            value: [],
          },
          to: {
            type: Date,
            value: new Date(),
          },
          currentTests: {
            type: Array,
          },
          isFeasible: {
            type: Boolean,
            computed: '_computeIsFeasible(tests, chunkSize, maxReqs)'
          },
        };
      }

      static get observers() {
        return [
          'loadNext(tests, chunkSize, labels, to, isFeasible)',
        ];
      }

      _computeLabels(labels) {
        return labels ? labels : [];
      }

      _computeCols(browserNames) {
        return [{label: 'Run time', type: 'datetime'}]
          .concat(browserNames.map(label => {
            return {label, type: 'number'};
          }));
      }

      _computeIsFeasible(tests, chunkSize, maxReqs) {
        if (!tests) {
          console.log('isFeasible: No tests');
          return false;
        }

        console.log('isFeasible:', `4 * ${tests.length} * ${chunkSize} <= ${maxReqs}`);
        console.log('isFeasible:', 4 * tests.length * chunkSize <= maxReqs);
        return 4 * tests.length * chunkSize <= maxReqs;
      }

      async loadNext(tests, chunkSize, labels, to, isFeasible) {
        if (!isFeasible || tests.length === 0) {
          return;
        }
        if (this.currentTests !== tests) {
          this.reset();
        }
        this.currentTests = tests;
        labels = labels || [];

        console.log('loadNext', tests, chunkSize, labels, to, isFeasible);

        const resp = await window.fetch(`/api/runs?complete=true&to=${to.toISOString()}&max-count=${chunkSize}&labels=${labels.join(',')}`);
        const runs = await resp.json();

        if (runs.length === 0) {
          return;
        }

        const latch = () => this.to = this.getDT(runs[runs.length - 1]);
        return Promise.all(runs.map(run => this.loadRun(this.currentTests, run)))
          .then(latch, latch);
      }

      async loadRun(tests, run) {
        if (this.tests !== tests) {
          return;
        }

        let num = 0;
        let denom = 0;
        await Promise.all(tests.map(async path => {
          const resp = await window.fetch(this.resultsURL(run, path));
          const r = await resp.json();
          if (this.tests !== tests) {
            return;
          }

          if (r.status === 'OK'|| r.status === 'PASS') {
            num++;
          }
          denom++;

          if (r.subtests && r.subtests.length > 0) {
            for (const sub of r.subtests) {
              if (sub.status === 'PASS') {
                num++;
              }
              denom++;
            }
          }
        }));
        if (this.tests !== tests) {
          return;
        }

        const dt = this.getDT(run);
        let values = this.values;
        const vIdx = values
          .findIndex(array => array[0].getTime() === dt.getTime());
        if (vIdx >= 0) {
          this.updateValue(values, vIdx, run.browser_name, num / denom);
        } else {
          const value = this.mkValue(dt);
          values = this.values.concat([value]).sort((array1, array2) => {
            return array1[0].getTime() - array2[0].getTime();
          });
          const vIdx = values
            .findIndex(array => array[0].getTime() === dt.getTime());
          this.updateValue(values, vIdx, run.browser_name, num / denom);
        }

        let latest = new Array(values[0].length + 1);
        let rows = new Array(values.length);
        for (let i = 0; i < values.length; i++) {
          rows[i] = new Array(values[i].length);
          rows[i][0] = values[i][0];
          for (let j = 1; j < latest.length; j++) {
            const value = values[i][j];

            // Feed latest values forward when no value in place.
            if (value === undefined && latest[j] !== undefined) {
              rows[i][j] = latest[j];
            }

            if (value !== undefined ) {
              rows[i][j] = value;

              // Backfill when label finds first value.
              if (latest[j] === undefined) {
                for (let k = i - 1; k >= 0; k--) {
                  rows[k][j] = value;
                }
              }

              latest[j] = value;
            }
          }
        }

        this.values = values;
        this.rows = rows;
      }

      mkValue(dt) {
        let row = new Array(this.cols.length);
        row[0] = dt;
        return row;
      }

      updateValue(rows, vIdx, label, value) {
        const labels = this.cols.map(col => col.label);
        let labelIdx;
        for (labelIdx = 0; labelIdx < labels.length; labelIdx++) {
          if (labels[labelIdx] === label) {
            rows[vIdx][labelIdx] = value;
            break;
          }
        }
        if (labelIdx === labels.length) {
          throw new Error(`Unknown label: ${label} (not one of ${labels.join(', ')})`);
        }

        return rows[vIdx];
      }

      resultsURL(run, path) {
        // This is relying on the assumption that result files end with '-summary.json.gz'.
        const resultsBase = run.results_url.slice(0, run.results_url.lastIndexOf('-summary.json.gz'));
        return `${resultsBase}${path}`;
      }

      reset() {
        this.rows = [];
      }

      getDT(run) {
        return this.dateFromString(run.start_time || run.created_at);
      }

      dateFromString(str) {
        const b = str.split(/\D+/);
        return new Date(Date.UTC(b[0], --b[1], b[2], b[3], b[4], b[5], b[6]));
      }
    }

    window.customElements.define(TestResultsChart.is, TestResultsChart);
  </script>
</dom-module>
