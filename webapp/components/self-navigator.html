<link rel="import" href="../bower_components/polymer/polymer-element.html">

<dom-module id='self-navigator'>
  <script>
    // eslint-disable-next-line no-unused-vars
    const SelfNavigation = (superClass) => class extends superClass {
      static get properties() {
        return {
          path: {
            type: String,
            value: '/',
            observer: 'pathUpdated',
          },
          encodedPath: {
            type: String,
            computed: 'encodeTestPath(path)'
          },
          isSubfolder: {
            type: Boolean,
            computed: 'computeIsSubfolder(path)',
          },
          onpathupdated: Function,
        };
      }

      ready() {
        super.ready();
        if (!this.path) {
          this.path = this.urlToPath(window.location);
        }
        window.onpopstate = () => {
          this.path = this.urlToPath(window.location);
        };
      }

      urlToPath(location) {
        let path = location.pathname;
        if (this.navigationPathPrefix() !== '') {
          // Strip prefix
          let prefixRe = RegExp(`^${this.navigationPathPrefix()}/(.+)?$`);
          path = path.replace(prefixRe, '/$1');
        }
        path = path.replace(/.+\/$/, ''); // Strip trailing slash
        return this.decodeTestPath(path);
      }

      // These are two helper functions to encode/decode the LAST component of
      // the test path, which may contain query strings (because of test
      // variants), e.g. "/dom/interfaces.html?exclude=Node" <-->
      // "/dom/interfaces.html%3Fexclude%3DNode".

      encodeTestPath(path) {
        console.assert(path.startsWith('/'));
        let parts = path.split('/').slice(1);
        parts.push(encodeURIComponent(parts.pop()));
        return '/' + parts.join('/');
      }

      decodeTestPath(path) {
        console.assert(path.startsWith('/'));
        let parts = path.split('/').slice(1);
        parts.push(decodeURIComponent(parts.pop()));
        return '/' + parts.join('/');
      }

      pathUpdated(path) {
        if (this.onpathupdated) {
          this.onpathupdated(path);
        }
      }

      computeIsSubfolder(path) {
        return path && path !== '/';
      }

      /**
       * Get the path prefix when creating history.
       */
      navigationPathPrefix() {
        return '';
      }

      /**
       * Get query params to persist when creating history.
       */
      navigationQueryParams() {
        return {};
      }

      bindNavigate() {
        return this.navigate.bind(this);
      }

      navigate(event) {
        // Don't intercept Ctrl+click or Meta(Win/Command)+click (open new tabs).
        if (event.ctrlKey || event.metaKey) {
          return;
        }
        event.preventDefault();
        this.navigateToLocation(event.target);
      }

      /**
       * Navigate to the path + query of the given Location object.
       */
      navigateToLocation(location) {
        const url = new URL(location);
        url.search = '';
        for (const [k, v] of Object.entries(this.navigationQueryParams())) {
          const list = (v instanceof Array) ? v : [v];
          for (const item of list) {
            url.searchParams.append(k, item);
          }
        }
        if (url.toString() === location.toString()) {
          return;
        }

        const path = this.urlToPath(location);
        if (path !== this.path) {
          this.path = path;
        }

        window.history.pushState({}, '', url);

        // Send Google Analytics pageview event
        if ('ga' in window) {
          window.ga('send', 'pageview', path);
        }
      }
    };
  </script>
</dom-module>
