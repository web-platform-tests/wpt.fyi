<!--
Copyright 2017 The WPT Dashboard Project. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
-->

<link rel="import" href="../bower_components/polymer/lib/elements/dom-if.html">
<link rel="import" href="../bower_components/paper-toggle-button/paper-toggle-button.html">
<link rel="import" href="test-runs.html">
<link rel="import" href="test-run.html">
<link rel="import" href="test-file-results-table-terse.html">
<link rel="import" href="test-file-results-table-verbose.html">

<dom-module id="test-file-results">
  <template>
    <style>
      :host {
        display: block;
        font-size: 16px;
      }
      h1 {
        font-size: 1.5em;
      }
      .right {
        display: flex;
        justify-content: flex-end;
      }
      .right .pad {
        padding: 8px;
      }
      paper-toggle-button {
        --paper-toggle-button-checked-bar-color:  var(--paper-blue-500);
        --paper-toggle-button-checked-button-color:  var(--paper-blue-700);
        --paper-toggle-button-checked-ink-color: var(--paper-blue-300);
      }
    </style>

    <div class="right">
      <label class="pad">Expand</label>
      <paper-toggle-button class="pad" checked="{{isVerbose}}">
      </paper-toggle-button>
    </div>

    <template is="dom-if" if="{{!isVerbose}}">
      <test-file-results-table-terse
          test-runs="[[testRuns]]"
          results-table="[[resultsTable]]">
      </test-file-results-table-terse>
    </template>

    <template is="dom-if" if="{{isVerbose}}">
      <test-file-results-table-verbose
          test-runs="[[testRuns]]"
          results-table="[[resultsTable]]">
      </test-file-results-table-verbose>
    </template>
  </template>

  <script>
    /* global TestRunsBase */
    class TestFileResults extends TestRunsBase {
      static get is() {
        return 'test-file-results';
      }

      static get properties() {
        return {
          resultsTable: {
            type: Array,
            value: [],
          },
          isVerbose: {
            type: Boolean,
            value: false,
          },
        };
      }

      async connectedCallback() {
        await super.connectedCallback();
        console.assert(this.path);
        console.assert(this.path[0] === '/');
      }

      static get observers() {
        return ['fetchTestFile(path, testRuns)'];
      }

      async fetchTestFile(path, testRuns) {
        this.subtestNames = []; // Clear any existing rows.
        if (!path || !testRuns) {
          return;
        }
        const resultsPerTestRun = await Promise.all(
          testRuns.map(tr => this.loadResultFile(tr)));

        // resultsTable[0].name set after discovering subtests.
        let resultsTable = [{
          results: resultsPerTestRun.map(data => {
            return {status: data && data.status};
          }),
        }];

        let subtestNamesSet = new Set();
        resultsPerTestRun
          .forEach(data => data && data.subtests && data.subtests
            .forEach(sub => subtestNamesSet.add(sub.name)));
        for (const subtestName of subtestNamesSet.values()) {
          resultsTable.push({
            name: subtestName,
            results: resultsPerTestRun
              .map(data => {
                if (!(data && data.subtests)) {
                  return {status: null, message: null};
                }
                const datum = data.subtests
                  .find(sub => sub.name === subtestName);
                if (!datum) {
                  return {status: null, message: null};
                }
                return {status: datum.status, message: datum.message};
              }),
          });
        }

        // Set name for test-level status entry after subtests discovered.
        resultsTable[0].name = resultsTable.length > 1 ? 'Harness status' :
          'Test status';

        this.resultsTable = resultsTable;
      }

      async loadResultFile(testRun) {
        const url = this.resultsURL(testRun, this.path);
        const response = await window.fetch(url);
        if (!response.ok) {
          return null;
        }
        return response.json();
      }

      resultsURL(testRun, path) {
        path = this.encodeTestPath(path);
        // This is relying on the assumption that result files end with '-summary.json.gz'.
        const resultsBase = testRun.results_url.slice(0, testRun.results_url.lastIndexOf('-summary.json.gz'));
        return `${resultsBase}${path}`;
      }
    }

    window.customElements.define(TestFileResults.is, TestFileResults);
  </script>
</dom-module>
