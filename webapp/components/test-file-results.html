<!--
Copyright 2017 The WPT Dashboard Project. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
-->

<link rel="import" href="../bower_components/polymer/lib/elements/dom-if.html">
<link rel="import" href="../bower_components/polymer/lib/elements/dom-repeat.html">
<link rel="import" href="runs.html">
<link rel="import" href="test-run.html">

<dom-module id="test-file-results">
  <template>
    <style>
      :host {
        display: block;
        font-size: 16px;
      }
      h1 {
        font-size: 1.5em;
      }

      table {
        width: 100%;
        border-collapse: collapse;
      }
      td.sub-test-name {
        font-family: monospace;
        font-size: 0.9em;
      }
      td.result {
        background-color: #eee;
      }
      td.result.OK, td.result.PASS {
        background-color: rgb(90, 242, 113);
      }
      td.result.FAIL {
        background-color: rgb(242, 90, 90);
      }
    </style>

    <table>
      <thead>
        <tr>
          <th width="[[computeSubtestThWidth(testRuns)]]">Subtest</th>
          <template is="dom-repeat" items="[[testRuns]]" as="testRun">
            <th width="[[computeRunThWidth(testRuns)]]"><test-run test-run="[[testRun]]"></test-run></th>
          </template>
        </tr>
      </thead>
      <tbody>
        <template is="dom-repeat" items="[[subtestNames]]" as="subtestName">
          <tr>
            <td class="sub-test-name">[[subtestName]]</td>

            <template is="dom-repeat" items="{{testRuns}}" as="testRun">
              <td class$="result [[ subtestResultForTestRun(testRun, subtestName) ]]">
                <code>[[ subtestMessageForTestRun(testRun, subtestName) ]]</code>
              </td>
            </template>
          </tr>
        </template>

      </tbody>
    </table>
  </template>

  <script>
    /* global TestRunsBase */
    class TestFileResults extends TestRunsBase {
      static get is() {
        return 'test-file-results';
      }

      static get properties() {
        return {
          testFile: {
            type: String,
            observer: 'testFileChanged'
          },
          subtestNames: {
            type: Array,
            value: []
          }
        };
      }

      async connectedCallback() {
        await super.connectedCallback();
        console.assert(this.testFile);
        console.assert(this.testFile[0] === '/');
        console.assert(this.testRuns);
        console.assert(this.testRuns.length > 0);

        this.fetchTestFile();
      }

      async fetchTestFile() {
        if (!this.testRuns) {
          return;
        }
        const resultPerTestRun = await Promise.all(this.testRuns.map(tr => this.loadResultFile(tr)));

        resultPerTestRun.forEach((resultData, i) => {
          if (!resultData) {
            this.testRuns[i].subtests = {};
            this.testRuns[i].subtests['Harness status'] = { status: '(results not found)' };
            return;
          }
          this.testRuns[i].subtests = {};
          this.testRuns[i].subtests['Harness status'] = { status: resultData.status };

          if (!this.subtestNames.includes('Harness status')) {
            this.subtestNames = this.subtestNames.concat(['Harness status']);
          }

          for (let subtestResult of resultData.subtests) {
            this.testRuns[i].subtests[subtestResult.name] = subtestResult;
            if (!this.subtestNames.includes(subtestResult.name)) {
              this.subtestNames = this.subtestNames.concat([subtestResult.name]);
            }
          }
        });

        // HACK: Force notifications on testRuns.
        this.testRuns = Array.from(this.testRuns);
      }

      async loadResultFile(testRun) {
        const url = this.resultsURL(testRun, this.testFile);
        const response = await window.fetch(url);
        if (!response.ok) {
          console.error(`Got non-OK status ${response.status} for url: ${url}`);
          return null;
        }
        return response.json();
      }

      testFileChanged() {
        this.subtestNames = [];
        this.fetchTestFile();
      }

      resultsURL(testRun, testFile) {
        if (testRun.revision === 'diff') {
          return `${testRun.results_url}&path=${encodeURI(testFile)}`;
        }
        // This is relying on the assumption that result files end with '-summary.json.gz'.
        const resultsBase = testRun.results_url.slice(0, testRun.results_url.lastIndexOf('-summary.json.gz'));
        return `${resultsBase}${testFile}`;
      }

      subtestResultForTestRun(testRun, subtestName) {
        if (!testRun) {
          return null;
        }
        if (!testRun.subtests) {
          return null;
        }
        if (!testRun.subtests[subtestName]) {
          return null;
        }
        return testRun.subtests[subtestName].status;
      }

      subtestMessageForTestRun(testRun, subtestName) {
        if (!testRun) {
          return null;
        }
        if (!testRun.subtests) {
          return null;
        }
        if (!testRun.subtests[subtestName]) {
          return null;
        }
        if (testRun.subtests[subtestName].status === 'OK') {
          return 'OK';
        }
        if (testRun.subtests[subtestName].status === 'PASS') {
          return 'PASS';
        }
        if (testRun.subtests[subtestName].message) {
          return this.parseFailureMessage(testRun.subtests[subtestName].message);
        }
        return testRun.subtests[subtestName].status;
      }

      parseFailureMessage(m) {
        const match = m.match(/^assert_equals:.* expected ("(\\"|[^"])*"|[^ ]*) but got ("(\\"|[^"])*"|[^ ]*)$/);
        if (match === null) {
          return`Failure message: ${m}`;
        }

        return `!EQ(${match[1]}, ${match[3]})`;
      }

      computeSubtestThWidth(testRuns) {
        return `${200 / (testRuns.length + 2)}%`;
      }

      computeRunThWidth(testRuns) {
        return `${100 / (testRuns.length + 2)}%`;
      }
    }

    window.customElements.define(TestFileResults.is, TestFileResults);
  </script>
</dom-module>
