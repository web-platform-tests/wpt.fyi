<!--
Copyright 2017 The WPT Dashboard Project. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
-->

<link rel="import" href="../bower_components/paper-button/paper-button.html">
<link rel="import" href="../bower_components/paper-spinner/paper-spinner-lite.html">
<link rel="import" href="../bower_components/paper-styles/color.html">
<link rel="import" href="../bower_components/paper-toast/paper-toast.html">
<link rel="import" href="../bower_components/paper-toggle-button/paper-toggle-button.html">
<link rel="import" href="../bower_components/polymer/lib/elements/dom-if.html">
<link rel="import" href="../bower_components/polymer/lib/elements/dom-repeat.html">
<link rel="import" href="../bower_components/polymer/polymer-element.html">
<link rel="import" href="path-part.html">
<link rel="import" href="results-navigation.html">
<link rel="import" href="self-navigator.html">
<link rel="import" href="test-run.html">
<link rel="import" href="test-runs.html">
<link rel="import" href="test-file-results.html">
<link rel="import" href="test-results-history-grid.html">
<link rel="import" href="test-results-chart.html">
<link rel="import" href="test-search.html">

<dom-module id="wpt-results">
  <template>
    <style>
      :host {
        display: block;
        font-size: 15px;
      }
      section.search {
        position: relative;
        border-bottom: solid 1px var(--paper-grey-300);
        padding-bottom: 1em;
        margin-bottom: 1em;
      }
      section.search .path {
        margin-top: 1em;
      }
      section.search paper-spinner-lite {
        position: absolute;
        top: 0;
        right: 0;
      }
      /* Direct access to test-search from local shadowRoot prevents using
       * `dom-if` for this. */
      section.search test-search.search-true {
        display: none;
      }
      table {
        width: 100%;
        border-collapse: collapse;
      }
      tr.spec {
        background-color: var(--paper-grey-200);
      }
      tr td {
        padding: 0 0.5em;
      }
      tr.spec td {
        padding: 0.2em 0.5em;
        border: solid 1px var(--paper-grey-300);
      }
      .path {
        margin-bottom: 16px;
      }
      .path-separator {
        padding: 0 0.1em;
      }
      .links {
        margin-bottom: 1em;
      }
      .info {
        padding: 0.5em;
        background-color: var(--paper-blue-100);
        margin-bottom: 1em;
        margin-top: 2em;
        border-left: solid 4px var(--paper-blue-300);
      }
      .info small {
        float: right;
      }
      .right {
        display: flex;
        justify-content: flex-end;
      }
      .right .pad {
        padding: 8px;
      }
      paper-toggle-button {
        --paper-toggle-button-checked-bar-color:  var(--paper-blue-500);
        --paper-toggle-button-checked-button-color:  var(--paper-blue-700);
        --paper-toggle-button-checked-ink-color: var(--paper-blue-300);
      }
      .top,
      .delta {
        background-color: var(--paper-grey-200);
      }
      .passes-0 { background-color: hsl(0, 85%, 65%); }
      .passes-20 { background-color: hsl(0, 85%, 70%); }
      .passes-40 { background-color: hsl(0, 85%, 75%); }
      .passes-60 { background-color: hsl(0, 85%, 80%); }
      .passes-80 { background-color: hsl(0, 85%, 85%); }
      .passes-100 { background-color: var(--paper-light-green-a400); }

      span.delta.negative {
        color: var(--paper-red-700);
      }
      span.delta.positive {
        color: var(--paper-green-700);
      }
      td {
        height: 1.5em;
        position: relative;
        padding: 0;
      }
      td.path-part {
        min-width: 200px;
        background-color: white;
      }
      td.none {
        visibility: hidden;
      }
      td.numbers {
        white-space: nowrap;
      }
      .terse td path-part {
        box-sizing: border-box;
        height: 100%;
        left: 0;
        overflow: hidden;
        padding: 0.25em;
        position: absolute;
        text-overflow: ellipsis;
        top: 0;
        white-space: nowrap;
        width: 100%;
      }
      .terse td path-part:hover {
        z-index: 1;
        text-overflow: initial;
        background-color: inherit;
        width: max-content;
      }
      .verbose td path-part {
        padding: 0.25em;
      }
      .yellow-button {
        color: var(--paper-yellow-500);
        margin-left: 32px;
      }
      .history {
        margin: 32px 0;
        text-align: center;
      }
      .history h3 span {
        color: var(--paper-red-500);
      }
      #show-history {
        background: var(--paper-blue-500);
        color: white;
      }

      @media (max-width: 800px) {
        table tr td:first-child::after {
          content: "";
          display: inline-block;
          vertical-align: top;
          min-height: 30px;
        }
      }
    </style>

    <results-navigation tab="results"
                        path="[[encodedPath]]"
                        query="[[query]]">
    </results-navigation>

    <section class="search">
      <div class="path">
        <a href="/results/" on-click="navigate">wpt</a>
        <template is="dom-repeat" items="{{ splitPathIntoLinkedParts(path) }}" as="part">
          <span class="path-separator">/</span>
          <a href="/results{{ part.path }}" on-click="navigate">{{ part.name }}</a>
        </template>
      </div>

      <paper-spinner-lite class="blue"></paper-spinner-lite>

      <test-search class$="search-[[pathIsATestFile]]" query='{{search}}'
          autocomplete-u-r-l="[[autocompleteURL]]"></test-search>

      <template is="dom-if" if="{{ pathIsATestFile }}">
        <div class="links">
          <ul>
            <li><a href$="https://github.com/web-platform-tests/wpt/blob/master[[sourcePath]]" target="_blank">View source on GitHub</a></li>
            <template is="dom-if" if="{{ testCanRunOnW3C }}">
              <li><a href$="[[scheme]]://w3c-test.org[[path]]" target="_blank">Run in your browser on w3c-test.org</a></li>
            </template>
          </ul>
        </div>
      </template>

      <template is="dom-if" if="{{ !isLatest }}">
        <section class="info">
          Showing results for run <b>{{ sha }}</b>.
          <small><a href='?sha=latest'>View latest run</a></small>
        </section>
      </template>
    </section>

    <template is='dom-if' if='[[isInvalidDiffUse(diff, testRuns)]]'>
      <paper-toast id="diffInvalid" duration="0" text="'diff' was requested, but is only valid when comparing two runs." opened>
        <paper-button on-click="hideDiffInvalidToast" class="yellow-button">Close</paper-button>
      </paper-toast>
    </template>

    <template is="dom-if" if="{{ pathIsATestFile }}">
      <test-file-results test-runs="[[testRuns]]"
                         path="[[path]]"
                         labels="[[labels]]"
                         products="[[products]]">
      </test-file-results>
    </template>

    <template is="dom-if" if="{{ !pathIsATestFile }}">

      <div class="right">
        <label class="pad">Expand</label>
        <paper-toggle-button class="pad" checked="{{isVerbose}}">
        </paper-toggle-button>
      </div>

      <table class$="[[tableClass]]">
        <thead>
          <tr>
            <th>Path</th>
            <template is="dom-repeat" items="{{testRuns}}" as="testRun">
              <!-- Repeats for as many different browser test runs are available -->
              <th><test-run test-run="[[testRun]]"></test-run></th>
            </template>
            <template is="dom-if" if="[[diffShown]]">
              <th><test-run test-run="[[diffRun]]"></test-run></th>
            </template>
          </tr>
        </thead>

        <tbody>

          <template is="dom-repeat" items="{{displayedNodes}}" as="node">
            <tr>
              <td class="path-part">
                <path-part prefix="/results" path="{{ node.path }}" is-dir="{{ node.isDir }}" navigate="{{ bindNavigate() }}"></path-part>
              </td>

              <template is="dom-repeat" items="{{testRuns}}" as="testRun">
                <td class$="numbers [[ testResultClass(node, index, testRun, 'passes') ]]">
                  <span class$="passes [[ testResultClass(node, index, testRun, 'passes') ]]">{{ getNodeResultDataByPropertyName(node, index, testRun, 'passes') }}</span>
                  /
                  <span class$="total [[ testResultClass(node, index, testRun, 'total') ]]">{{ getNodeResultDataByPropertyName(node, index, testRun, 'total') }}</span>
                </td>
              </template>
              <template is="dom-if" if="[[diffShown]]">
                <td class$="numbers [[ testResultClass(node, index, diffRun, 'passes') ]]">
                  <span class$="passes [[ testResultClass(node, index, diffRun, 'passes') ]]">{{ getNodeResultDataByPropertyName(node, -1, diffRun, 'passes') }}</span>
                  /
                  <span class$="total [[ testResultClass(node, index, diffRun, 'total') ]]">{{ getNodeResultDataByPropertyName(node, -1, diffRun, 'total') }}</span>
                </td>
              </template>
            </tr>
          </template>

        </tbody>
      </table>
    </template>

    <template is="dom-if" if="[[isSubfolder]]">
      <div class='history'>
        <template is="dom-if" if="[[!showHistory]]">
          <paper-button id='show-history' onclick="[[showHistoryClicked()]]" raised>
            Show history
          </paper-button>
        </template>
        <template is="dom-if" if="[[showHistory]]">
          <h3>
            History <span>(Experimental)</span>
          </h3>
          <test-results-chart
              path="[[path]]"
              labels="[[labels]]"
              tests="[[displayedTests]]">
          </test-results-chart>

          <template is="dom-if" if="[[pathIsATestFile]]">
            <test-results-history-grid
                path="[[path]]"
                labels="[[labels]]"
                tests="[[displayedTests]]">
            </test-results-history-grid>
          </template>
        </template>
      </div>
    </template>

  </template>

  <script>
    const TEST_TYPES = ['manual', 'reftest', 'testharness', 'visual', 'wdspec'];

    /* global TestRunsBase, SelfNavigation */
    class WPTResults extends SelfNavigation(TestRunsBase) {
      static get is() {
        return 'wpt-results';
      }

      static get properties() {
        return {
          search: {
            type: String,
            value: '',
          },
          sourcePath: {
            type: String,
            computed: 'computeSourcePath(path, manifest)',
          },
          testCanRunOnW3C: {
            type: Boolean,
            computed: 'computeTestCanBeRunOnW3C(path, manifest)',
          },
          searchResults: {
            type: Array,
            value: [],
          },
          displayedNodes: {
            type: Array,
            value: [],
          },
          displayedTests: {
            type: Array,
            computed: 'computeDisplayedTests(path, searchResults)',
          },
          // Users request to show a diff column.
          diff: Boolean,
          diffRun: {
            type: Object,
            value: null,
          },
          // A diff column is shown if requested by users and there are 2 testRuns.
          diffShown: {
            type: Boolean,
            computed: 'isDiffShown(diff, diffRun)',
          },
          // Override TestRunsBase to add diff.
          queryParams: {
            type: Object,
            computed: 'testRunQueryParams(sha, labels, products, maxCount, diff)',
          },
          filter: {
            type: String,
            value: 'ADCU', // Added, Deleted, Changed, Unchanged
          },
          showHistory: {
            type: Boolean,
            value: false,
          },
          searchURL: {
            type: String,
            computed: 'computeSearchURL(testRuns, search)',
          },
          autocompleteURL: {
            type: String,
            computed: 'computeAutocompleteURL(testRuns, search)',
          },
          loadingCount: {
            type: Number,
            value: 0,
            observer: 'observeLoadingCount',
          },
          isVerbose: {
            type: Boolean,
            value: false,
          },
          tableClass: {
            type: String,
            computed: 'computeTableClass(isVerbose)',
          },
          onSearchCommit: Function,
        };
      }

      isDiffShown(diff, diffRun) {
        return diff && diffRun !== null;
      }

      isInvalidDiffUse(diff, testRuns) {
        return diff && testRuns && testRuns.length !== 2;
      }

      hideDiffInvalidToast() {
        this.shadowRoot.querySelector('#diffInvalid').toggle();
      }

      computeSourcePath(path, manifest) {
        if (!this.computePathIsATestFile(path) || !manifest) {
          return path;
        }
        // Filter in case any types are fully missing.
        const itemSets = TEST_TYPES.map(t => manifest.items[t]).filter(i => i);
        for (const items of itemSets) {
          const key = Object.keys(items).find(k => items[k].find(i => i[0] === path));
          if (key) {
            // Ensure leading slash.
            return key.startsWith('/') ? key : `/${key}`;
          }
        }
        return null;
      }

      computeTestCanBeRunOnW3C(path, manifest) {
        if (!this.computePathIsATestFile(path) || !manifest) {
          return true;
        }
        for (const type of TEST_TYPES) {
          const items = manifest.items[type];
          if (items) {
            const test = Object.keys(items).find(k => items[k].find(i => i[0] === path));
            if (test && type === 'wdspec') {
              return false;
            }
          }
        }
        return true;
      }

      computeDisplayedTests(path, searchResults) {
        return searchResults.map(r => r.test)
          .filter(name => name.startsWith(path));
      }

      computeSearchURL(testRuns, search) {
        let url = '/api/search?';
        if (testRuns) {
          url += `run_ids=${
            window.encodeURIComponent(
              testRuns.map(r => r.id.toString()).join(','))}&`;
        }
        if (search) {
          url += `q=${window.encodeURIComponent(search)}`;
        }
        return url;
      }

      computeAutocompleteURL(testRuns, search) {
        let url = '/api/autocomplete?limit=10&';
        if (testRuns) {
          url += `run_ids=${
            window.encodeURIComponent(
              testRuns.map(r => r.id.toString()).join(','))}&`;
        }
        if (search) {
          url += `q=${window.encodeURIComponent(search)}`;
        }
        return url;
      }

      computeTableClass(isVerbose) {
        return isVerbose ? 'verbose' : 'terse';
      }

      observeLoadingCount(newValue, oldValue) {
        if (newValue === oldValue) {
          return;
        }
        const elem = this.shadowRoot.querySelector('paper-spinner-lite');
        if (!elem) {
          return;
        }

        if (newValue && !oldValue) {
          elem.setAttribute('active', 'true');
        } else if (!newValue && oldValue) {
          elem.removeAttribute('active');
        }
      }

      constructor() {
        super();
        this.onSearchCommit = this.handleSearchCommit.bind(this);
      }

      connectedCallback() {
        super.connectedCallback();
        this.shadowRoot.querySelector('test-search')
          .addEventListener('commit', this.onSearchCommit);
      }

      disconnectedCallback() {
        this.shadowRoot.querySelector('test-search')
          .removeEventListener('commit', this.onSearchCommit);
        super.disconnectedCallback();
      }

      ready() {
        super.ready();
        this.loadRuns().then(async runs => {
          this.fetchResults();

          // Load a diff data into this.diffRun, if needed.
          if (this.diff && runs && runs.length === 2) {
            this.diffRun = {
              revision: 'diff',
              browser_name: 'diff',
            };
          }
        });

        // NOTE(lukebjerring): Overriding the pathUpdated method doesn't get
        // called, so we wrap any given onpathupdated methd here.
        const onpathupdated = this.onpathupdated;
        this.onpathupdated = path => {
          onpathupdated && onpathupdated(path);
          this.showHistory = false;
        };
      }

      async fetchResults() {
        this.loadingCount++;
        try {
          const response = await window.fetch(this.searchURL);
          if (response.status !== 200) {
            throw response;
          }
          const json = await response.json();
          this.searchResults = json.results;
          this.refreshDisplayedNodes();
        } finally {
          this.loadingCount--;
        }
      }

      pathUpdated(path) {
        super.pathUpdated(path);
        this.refreshDisplayedNodes();
        this.fetchManifest(path);
      }

      async fetchManifest(path) {
        if (!this.computePathIsATestFile(path)) {
          return;
        }
        path = this.encodeTestPath(path);
        this.manifest = null; // Clear ASAP.
        this.manifest = await fetch(`/api/manifest?path=${path}`).then(r => r.json());
      }

      nodeSort(a, b) {
        if (a.path < b.path) {
          return -1;
        }
        if (a.path > b.path) {
          return 1;
        }
        return 0;
      }

      refreshDisplayedNodes() {
        // Prefix: includes trailing slash.
        const prefix = this.path === '/' ? '/' : `${this.path}/`;
        const pLen = prefix.length;
        this.displayedNodes = this.searchResults
          // Filter out files not in this directory.
          .filter(r => r.test.startsWith(prefix))
          // Accumulate displayedNodes from remaining files.
          .reduce((() => {
            // Bookkeeping of the form:
            //   {<displayed dir/file name>: <index in acc>}.
            let nodes = {};
            return (acc, r) => {
              // Compute dir/file name that is direct descendant of this.path.
              const suffix = r.test.substring(pLen);
              const slashIdx = suffix.indexOf('/');
              const isDir = slashIdx !== -1;
              const name = isDir ? suffix.substring(0, slashIdx): suffix;

              // Either add new node to acc, or add passes, total to an
              // existing node.
              if (!nodes.hasOwnProperty(name)) {
                nodes[name] = acc.length;
                acc.push({
                  path: `${prefix}${name}`,
                  isDir,
                  results: Array.from(r.legacy_status),
                });
              } else {
                const rs = r.legacy_status;
                const nrs = acc[nodes[name]].results;

                for (let i = 0; i < rs.length; i++) {
                  nrs[i].passes += rs[i].passes;
                  nrs[i].total += rs[i].total;
                }
              }

              return acc;
            };
          })(), [])
          // TODO(markdittmer): Is this still necessary?
          .sort(this.nodeSort);
      }

      platformID({browser_name, browser_version, os_name, os_version}) {
        return `${browser_name}-${browser_version}-${os_name}-${os_version}`;
      }

      navigationPathPrefix() {
        return '/results';
      }

      navigationQueryParams() {
        return this.queryParams;
      }

      testResultClass(node, index, testRun, prop) {
        // Guard against incomplete data.
        if (!node || !testRun) {
          return 'none';
        }

        const result = node.results[index];
        const isDiff = this.isDiff(testRun);
        if (isDiff) {
          // Diff case: 'delta [positive|negative|<nothing>]' based on delta
          // value;
          const delta = this.getDiffDelta(node, prop);
          if (delta === 0) {
            return 'delta';
          }

          return `delta ${delta > 0 ? 'positive' : 'negative'}`;
        } else {
          // Non-diff case: total=0 -> 'none'; path='/' -> 'top';
          // otherwise -> 'passes-[colouring-by-percent]'.
          if (typeof result === 'undefined' && prop === 'total') {
            return 'none';
          }
          if (this.path === '/') {
            return 'top';
          }

          const passes = result.passes / result.total;
          return `passes-${passes * 100 - (passes * 100 % 20)}`;
        }
      }

      getDiffDelta(node, prop) {
        return node.results[1][prop || 'passes'] -
          node.results[0][prop || 'passes'];
      }

      getDiffDeltaStr(node, prop) {
        const delta = this.getDiffDelta(node, prop);
        if (delta === 0) {
          return '0';
        }
        const posOrNeg = delta > 0 ? '+' : '';
        return `${posOrNeg}${delta}`;
      }

      hasResults(node, testRun) {
        return typeof node.results[testRun.results_url] !== 'undefined';
      }

      isDiff(testRun) {
        return testRun && testRun.revision === 'diff';
      }

      testRunQueryParams(sha, labels, products, maxCount, diff) {
        const params = super.testRunQueryParams(sha, labels, products, maxCount);
        if (diff || this.diff) {
          params.diff = true;
        }
        return params;
      }

      getNodeResultDataByPropertyName(node, index, testRun, property) {
        if (this.isDiff(testRun)) {
          return this.getDiffDeltaStr(node, property);
        }
        if (index >= 0 && index < node.results.length) {
          return node.results[index][property];
        }
      }

      /* Function for getting total numbers.
       * Intentionally not exposed in UI.
       * To generate, open your console and run:
       * document.querySelector('wpt-results').generateTotalPassNumbers()
       */
      generateTotalPassNumbers() {
        const totals = {};

        this.testRuns.forEach(testRun => {
          const testRunID = this.platformID(testRun);
          totals[testRunID] = {passes: 0, total: 0};

          Object.keys(this.specDirs).forEach(specKey => {
            let { passes, total } = this.specDirs[specKey].results[testRun.results_url];

            totals[testRunID].passes += passes;
            totals[testRunID].total += total;
          });
        });

        Object.keys(totals).forEach(key => {
          totals[key].percent = (totals[key].passes / totals[key].total) * 100;
        });

        console.table(Object.keys(totals).map(k => ({
          platformID: k,
          passes: totals[k].passes,
          total: totals[k].total,
          percent: totals[k].percent
        })));

        console.log('JSON version:', JSON.stringify(totals));
      }

      showHistoryClicked() {
        return () => {
          this.showHistory = true;
        };
      }

      handleSearchCommit() {
        // Fetch search results when test-search signals that user has committed
        // to search string (by pressing <Enter>).
        this.fetchResults();
      }
    }

    window.customElements.define(WPTResults.is, WPTResults);
  </script>
</dom-module>
