<!--
Copyright 2018 The WPT Dashboard Project. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
-->

<link rel="import" href="../bower_components/polymer/lib/elements/dom-repeat.html">
<link rel="import" href="runs.html">

<dom-module id="test-file-results-time-series">
  <template>
    <style>
      .browser {
        display: flex;
      }
      .browser-name {
        writing-mode: vertical-rl;
        text-orientation: sideways-right;
        border-right: 1px solid black;
        padding: 8px 4px;
      }
      .browser-result {
        padding: 8px 0;
      }
      .browser-results {
        display: flex;
      }
      .browser-result-status {
        cursor: default;
        border: 1px solid #ddd;
        background-color: #eee;
        width: 10px;
        height: 10px;
      }
      .browser-result-status.OK, .browser-result-status.PASS {
        background-color: rgb(90, 242, 113);
      }
      .browser-result-status.FAIL {
        background-color: rgb(242, 90, 90);
      }
    </style>
    <template is="dom-repeat" items="[[results]]" as="browserResults">
      <div class="browser">
        <div class="browser-name">[[browserResults.browserName]]</div>
        <div class="browser-results"></div>
        <template is="dom-repeat" items="[[browserResults.runResults]]" as="runResult">
            <div class="browser-result">
              <!-- Tooltip or something associated with run? -->
              <template is="dom-repeat" items="[[runResult.results]]" as="result">
                <div
                    class$="browser-result-status [[result.status]]"
                    onmouseenter="[[bindResultHover(runResult.run, result.name)]]">&nbsp;</div>
              </template>
            </div>
        </template>
      </div>
    </template>

    <pre id="status">&nbsp;</pre>
  </template>
  <script>
    class TestFileResultsTimeSeries extends TestRunsBase {
      static get is() {
        return 'test-file-results-time-series';
      }

      static get properties() {
        return {
          path: {
            type: String,
          },
          maxCount: {
            type: Number,
            value: 20,
          },
          labels: {
            type: Array,
            value: [],
          },
          results: {
            type: Array,
            value: [],
          },
        };
      }

      static get observers() {
        return [
          'onTestRuns(testRuns)',
        ];
      }

      bindResultHover(run, subTestName) {
        return () => {
          let statusElement = this.shadowRoot.querySelector('#status');
          statusElement.textContent =
              `${run.browser_name} ${run.browser_version} ${run.os_name} ${run.os_version} @ ${run.time_start} : ${subTestName}`;

        }
      }

      async connectedCallbacke() {
        const resp = await window.fetch(`/api/runs?complete=true&max-count=${this.maxCount}&labels=${this.labels.join(',')}`);
        if (!resp.ok) throw resp;
        const runs = await resp.json();
        this.results = runs.reduce((acc, run) => {
          const browserResultsIdx = acc
              .findIndex(br => br.browserName === run.browser_name);
          let browserResults = acc[browserResultsIdx];
          if (!browserResults) {
            browserResults = {
              browserName: run.browser_name, 
              runResults: [],
            };
            acc.push(browserResults);
            // this.results.push(browserResults);
            // this.notifyPath('results');
            // this.push('results', browserResults);
          }
          browserResults.runResults.push({run, results: []});
          // this.push(`results.${browserResultsIdx}.runResults`,
          //     runResult);
          
          return acc;
        }, []);
        this.results.forEach((browserResults, i) => {
          browserResults.runResults.forEach((runResult, j) => {
            this.loadRun({
              runResult,
              j,
              browserResults,
              i,
            });
          });
        });
      }

      async loadRun(data) {
        const resp = await window.fetch(this.resultsURL(data.runResult.run));
        if (!resp.ok) throw resp;
        const results = await resp.json();
        let newResults = [];
        for (const r of results.results) {
          if (r.test === this.path) {
            newResults.push({status: r.status});
            data.runResult.results.push({status: r.status});
            if (r.subtests && r.subtests.length > 0) {
              for (const sub of r.subtests) {
                newResults.push({name: sub.name, status: sub.status});
              }
            }
            break;
          }
        }
        // this.results[data.i].runResults[data.j].results = newResults;
        // this.notifyPath(`results[${data.i}].runResults[${data.j}]`);
        this.splice.apply(this, [
          `results.${data.i}.runResults.${data.j}.results`, 
          0, 
          0,
        ].concat(newResults));

        console.log(`results[${data.i}].runResults[${data.j}]`, this.results);
      }

      resultsURL(run) {
        // This is relying on the assumption that result files end with '-summary.json.gz'.
        const resultsBase = run.results_url.slice(0, testRun.results_url.lastIndexOf('-summary.json.gz'));
        return `${resultsBase}${this.path}`;
      }

      onTestRuns(testRuns) {
        this.results = testRuns.reduce((acc, run) => {
          const browserResultsIdx = acc
              .findIndex(br => br.browserName === run.browser_name);
          let browserResults = acc[browserResultsIdx];
          if (!browserResults) {
            browserResults = {
              browserName: run.browser_name, 
              runResults: [],
            };
            acc.push(browserResults);
            // this.results.push(browserResults);
            // this.notifyPath('results');
            // this.push('results', browserResults);
          }
          browserResults.runResults.push({
            run, 
            results: run.subtests ? Object.keys(run.subtests)
                .map(name => {
                  return {name, status: run.subtests[name].status};
                }) : [],
          });
          // this.push(`results.${browserResultsIdx}.runResults`,
          //     runResult);
          
          return acc;
        }, []);
        console.log('testRuns', testRuns);
      }
    }

    window.customElements.define(TestFileResultsTimeSeries.is, TestFileResultsTimeSeries);
  </script>
</dom-module>
